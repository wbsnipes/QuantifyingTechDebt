\begin{center}
\begin{table*}[t]
	\centering
	\caption{Class Structure Data}
	\begin{tabular}{|l|l|l|l|l|l|}
	\hline

Class Name & Count Class Base & Count Class Coupled & Count Class Derived & Count Line Code & Count Declared Method\\
\hline\hline
Class A & 10 & 272 & 1 & 15040 & 247\\
\hline
Class B & 3 & 98 & 0 & 9360 & 52\\
\hline
Class C & 1 & 32 & 0 & 2851 & 28\\
\hline

	\end{tabular}
	\label{fig:ClassStructureAnalysisData}
\end{table*}
\end{center}

\begin{center}
\begin{table*}[t]
	\centering
	\caption{Class Data from Logs}
	\begin{tabular}{|l|l|l|l|l|l|l|}
	\hline

Developer Name & Class Name & No Of sessions &Count No of Class Edits & Count No of Other Class Accesses & Time Spent in Class & Time Spent in Other Classes\\
\hline\hline
Developer X & A & 74 & 294 & 78 & 39hours 34mins 23 secs & 16hours 39mins 36secs\\
\hline
Developer X & B & 32 & 88 & 52 & 2hours 54mins 20 secs & 8hours 54mins 18secs\\
\hline
Developer X & C & 28 & 77 & 52 & 4hours 28mins 25 secs & 9hours 15mins 41secs\\
\hline
Developer Y & P & 10 & 45 & 24 & 2hours 19mins 13 secs & 1hour 43mins 12secs\\
\hline
Developer Y & Q & 7 & 12 & 20 & 24mins 08 secs & 2hours 36mins 32secs\\
\hline
Developer Y & R & 5 & 15 & 16 & 53mins 51secs & 40mins 18secs\\
\hline

	\end{tabular}
	\label{fig:ClassAnalysisData}
\end{table*}
\end{center}

As previously mentioned we first define sessions to investigate each class that a developer visits. We define session as a moving window time where developer is investigating a certain class. When we define a session of X hours for a class Y we mean to say that starting from the first time the developer visits class Y while navigating we find the last time he visits the same class in X hours. For each session of class Y that we obtain we study the number of unique classes the developer has visited while in the session as well as the number of times the developer has visited the class Y iteslf within the session. The classes central to a task will have a high count of the number of times the developer visits the class in a particular session and the number of such sessions will also be high. We also calculate the time spent by developer in the central class as well as the time spent by the developer spent in other classes in the session of the central class.The time factor gives us an estimation of how well the developer comprehends the class and other classes referenced in the session. We studied such sessions for a moving window of 4 hours, 8 hours, 12 hours and 16 hours. 

The data collected by the Blaze logs has all the navigation activities done by the developer in the IDE. It also has appropriate time outs for periods of inactivity in the IDE. We first filtered out all the navigation activities related to classes as well all time outs and IDE exits. Next we calculated the time spent by the developer in the class. We obtained a list of such classes and the time spent by the user in each class. We observed there were instances when the developer accessed a class for less than a second and then switched to another class. We assumed that no useful comprehension can be done by the user in less than a second and attributed such class accesses to random clicks and removed all such entries. We then calculated various parameters that would help in identifying the central class as well the neccesary classes for comprehending the central class. For each sliding window size we calculated the following parameters:
\begin{itemize}
	\item[] Number of sessions formed by each class (No Of sessions).
	\item[] Number of times the class itself has been accessed inside the session (Count No of Class Edits).
	\item[] Number of unique files visited in each session (Count No of Other Class Accesses).
	\item[] Time spent in the class that forms the session (Time Spent in Class).
	\item[] Time spent in all other files in the session (Time Spent in Other Classes). 
\end{itemize}
We observed that there was a small change in the number of sessions formed by each class between the 4 hour moving window and the 8 hour moving window. The fact that there is not a huge downslide from the 4 hour window to the 8 hour window means that developers do not very often work in 8 hour windows but rather more often do so in 4 hour windows. The 8 hour moving window formed the same number of sessions as that of the 12 hour and 16 hour window. Since the difference was not much between the 4 hour and 8 hour sliding window we decided to use the 4 hour sliding window for further analysis.

Table~\ref{fig:ClassStructureAnalysisData} refers to the structural analysis of each of the classes that we have used for this study. The parameters for the structural analysis are standard code metrics used by various tools for static analysis of code \Fix{Do i need to refer some literature on code metrics?}. We use the code metrics of Count Class Base which is the number of immediate base classes, Count Class Coupled which is the count of other classes coupled to the class, Count Class Derived which is the number of immediate subclasses, Count Line Code which is the total number of lines containing the source code and Count Declared Method which is the number of local methods for the class. These code metrics are generated for a group of 9888 classes in a project. The Count Class Coupled for class A is the highest compared to all the classes in the project. Also the other code metrics are all in the top 20 for class A when compared to all other classes in the project. The high numbers indicate \Fix{How do i tie it back to code maintenance? Just saying that they are raw indicators is safe?}

Table~\ref{fig:ClassAnalysisData} shows data for each developer that we investigated. We present 3 classes for each of the developers. Each column represents the 5 parameters we defined to be useful in quantifying the \TD. As you can see for developer X we observe a very high count of the number of sessions as well as high counts in number of class edits and number of other class accesses for Class A. This suggests that the developer referenced Class A over a long period of time and very frequently. The developer also frequently referred to other classes while working on Class A. The data shows that the developer spent more than 39 hours working on Class A and more than 16 hours referencing other classes. The 16 hours the developer spent on other files can be interpreted as a cost of comprehending class A that can be veiwed as  \TD. Similarly when we see Class B we see that developer X spent nearly 3 hours on Class B but spent nearly 9 hours referencing other classes. This indicates that the developer spent 3 times the time actually spent on the central class in other classes. Only taking time as a factor cannot lead to such conclusions and we need to make sure that the class that we consider as the session is central to the task at hand. In this case the developer has 32 such sessions of Class B where he has also referenced Class B 88 times in these sessions. We can safely say that the developer keeps coming back to class B and thus it must be central to the task. Similar patterns can be seen in developer Y where each parameter is indicative of the fact that the considered class is indeed the central class and that the time spent navigating other classes has a significant impact in calculating \TD. Now when we look at the parameters that we obtained from the log together with the code metrics we generated for the files we can see how the high numbers of Class A can be seen in both code metrics as well as navigation data. The navigation data shows the time spent by a developer in editing and comprehending class A is on the higher end and the fact that the code metrics shows us that it is the highest coupled class and one of the longest in terms of lines of source code we now know that the maintenance cost of class A is very high.\Fix{Something more needs to be written here but do not know what?}
